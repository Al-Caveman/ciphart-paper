\documentclass[twocolumn]{article}
\usepackage[margin=.7in]{geometry}
\usepackage[showisoZ=false]{datetime2}
\usepackage{url}
\usepackage{tabularx}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\DeclareMathOperator{\enc}{\texttt{enc}}
\DeclareMathOperator{\maxf}{max}
\DeclareMathOperator{\len}{len}
\DeclareMathOperator{\hash}{\texttt{hash}}
\DeclareMathOperator{\kdf}{\texttt{ciphart}}
\renewcommand{\contentsname}{paper's layout}
\makeatletter
\def\myrulefill{%
    \leavevmode\leaders\hrule%
    height .6ex width 1ex depth -0.4ex%
    \hfill\kern\z@%
}
\makeatother
\DTMsetdatestyle{iso}
\usepackage{cleveref} % must be loaded last
\begin{document}
\SetAlgorithmName{algorithm}{}{list of algorithms}
\SetInd{.15em}{1em}

\begin{center}
\Huge
\myrulefill\ ciphart \myrulefill\\
\LARGE
memory-hard key derivation \\
with easier measurable security\\
\normalsize
caveman\footnote{mail: toraboracaveman [at] protonmail [dot] com}\\
\footnotesize
\DTMnow\\
\rule{1\columnwidth}{2pt}
\end{center}

\emph{argon2}\footnote{\url{https://github.com/P-H-C/phc-winner-argon2}} is
mostly nice, but trying to interpret its contribution to the protection
against password brute-forcing attacks remains more difficult than it
should be.  this vagueness is a problem that is not limited to
\emph{argon2}, but also shared with every other key derivation function
that i've known so far.

when one uses \emph{argon2}, his derived key will surely have superior
protection against password brute-forcing attacks, but by how much?  to
answer this, one would need to survey the industry that manufactures
application-specific integrated circuits (asics) to obtain a map between
\emph{time} and \emph{money}, in order to get an estimation on how much
would it cost the adversary to discover the password in a given time
window.

while the approach of surveying the asics industry is not wrong, it is
largely subjective, with expensive housekeeping, and practically leads the
user to rely on vague foundations to build his security on.  this vagueness
is not nice, and it would be better if we had an objective measure to
quantify the security of our memory-hard key derivation functions.

resolving this vagueness is not a mere luxury to have, but a necessity for
maximising survival, because it hinders the process of studying the
cost-value of memory-hard key derivation functions, which, effectively,
increases the risk of having a false sense of security.

so i propose \emph{ciphart} --- a memory-hard key derivation function with
a security contribution that is measured in a unit that i call
\emph{relative entropy bits}.  this unit is measured objectively and is
guaranteed to be true irrespective of whatever alien technology that the
adversary might have.

\texttt{libciphart}\footnote{\url{https://github.com/Al-Caveman/libciphart}}
is a library that implements \emph{ciphart} very closely to this paper,
without much fluff.  this should make integrating \emph{ciphart} into other
systems more convenient.

\texttt{ciphart}\footnote{\url{https://github.com/Al-Caveman/ciphart}} is
an application for encrypting and decrypting files that makes use of
\texttt{libciphart}.  this application is intended for use by end-users or
scripts, henceforth it has some fluff to treat mankind with dignity.

\tableofcontents
\noindent
\rule{1\columnwidth}{2pt}

\section{ciphart}
\subsection{parameters}
\begin{tabularx}{\columnwidth}{lX}
    $\enc$ & encryption function.\\
    $p$ & password.\\
    $s$ & salt.\\
    $M$ & total memory in bytes.\\
    $L$ & number of memory lanes for concurrency.\\
    $T$ & number of tasks per lane segment.\\
    $B$ & minimum quantity of increased protection against password
            brute-forcing attacks in the unit of \emph{relative entropy
            bits}.\\
    $K$ & output key size in bytes.\\
\end{tabularx}

\subsection{internal variables}
\begin{tabularx}{\columnwidth}{lX}
    $\hash$ & hashing function.\\
    $C$         & $\gets \begin{cases}
                        64 \text{ bytes} & \text{if $\enc$ is
                                            \emph{xchacha20}}\\
                        16 \text{ bytes} & \text{if $\enc$ is \emph{aes}}\\
                        \ldots & \\
                     \end{cases}$\\
                & this to reflect the block size of the encryption
                    algorithm that implements $\enc$.\\
    $V$ & $\gets \begin{cases}
                        32 \text{ bytes} & \text{if $\enc$ is
                                            \emph{xchacha20}}\\
                        16 \text{ bytes} & \text{if $\enc$ is
                            \emph{aes-128}}\\
                        32 \text{ bytes} & \text{if $\enc$ is
                            \emph{aes-256}}\\
                        \ldots & \\
                     \end{cases}$\\
                & this is the size of the encryption key that's used to
                    solve \emph{ciphart}'s tasks.  this is different than
                    the $\enc$-independent $K$ which is
                    possibly used by other encryption algorithms in later
                    stages\footnote{at the expense of losing the meaning of
                    \emph{relative entropy bits}.}.\\
    $\hat T$    & $\gets \maxf(\lceil V C^{-1}\rceil, T)$.  this
                    is to ensure that we have enough encrypted bytes for
                    new keys.\\
    $\hat T$    & $\gets \hat T - (\hat T \bmod 2) + 2$.  this is to ensure
                    that there is an even number of tasks in a segment.
                    why?  because we need a buffer for storing the
                    clear-text and another for storing the output
                    cipher-text.\\
\end{tabularx}
\begin{tabularx}{\columnwidth}{lX}
    $\hat M$    & $\gets M - (M \bmod C\hat TL) + C\hat TL$.  this is to
                    ensure that it is in multiples of $C\hat TL$.  why?  so
                    that all segments are of equal lengths in order to
                    simplify \emph{ciphart}'s logic.  e.g. it wouldn't be
                    nice if the last segments were of unequal sizes.\\
    $G$         & $\gets \hat MC^{-1}\hat T^{-1}L^{-1}$.  total number of
                    segments per lane.\\
    $N$    & $\gets 0$.  actual number of times $\enc$ is called,
                    where $\hat N \ge 2^B$.\\
    $m_i$       & $C$-bytes memory for $i^{th}$ task in the $\hat M$-bytes
                    pad.\\
    $n_l$       & $\gets lG\hat T$.  nonce variable for $l^{th}$ lane with
                    at least $64$ bits.\\
    $f$         & $\gets 0$.  a flag indicating whether the $\hat M$-bytes
                    pad is filled.\\
    $v$         & $\gets *\hash(p \mathbin\Vert s, V)$.  a pointer to the
                    first byte where $V$-bytes key is stored.\\
\end{tabularx}

\subsection{output}
\begin{tabularx}{\columnwidth}{lX}
$k$ & $K$-bytes key with an increased protection against brute-forcing
attacks by $\log_2 N$ \emph{relative entropy bits}.\\
\end{tabularx}

\subsection{steps}
steps of \emph{ciphart} is shown in \cref{alg_ciphart}.  this corresponds
to \emph{argon2d}.  adding a \emph{ciphart-i} variant is a trivial matter,
i just didn't do it yet because my threat model currently doesn't benefit
from a password independent variant.

\begin{algorithm}[tbh]
\While{$1$}{
    \For{$g=0, 1, \ldots, G-1$}{
        \For{$l=0, 1, \ldots, L-1$}{\label{ciphart_lanes}
            \For{$t=0, 1, \ldots, T-1$}{
                $i \gets gLT + lT + t$\;
                \uIf{$t < T - 1$}{
                    $j \gets i + 1$\;
                }\ElseIf{$t = T - 1$}{
                    $j \gets i - T + 1$\;
                }
                $m_j \gets \enc(m_i, n_l, v)$\;
                $n_l \gets n_l + 1$\;
                \uIf{$f = 0$}{
                    $v \gets m_j \bmod (gLTC + tC - V)$\;
                    \If{$v \ge gLTC - V$}{
                        $v \gets v + lTC$\;
                    }
                }\Else{
                    $v \gets m_j \bmod (\hat M - LTC + tC - V)$\;
                    \uIf{$v \ge gLTC + tC - V$}{
                        $v \gets v + LTC$\;
                    }\ElseIf{$v \ge gLTC - V$}{
                        $v \gets v + lTC$\;
                    }
                }
            }
        }
        $N \gets N + LT$\;
        \If{$N \ge 2^B$}{
            $g_{\text{last}} \gets g$\;
            \textbf{go to} \cref{ciphart_out}\;
        }
    }
    $f \gets 1$\;
}
$i \gets g_{\text{last}}LT$\;\label{ciphart_out}
$k \gets \hash(m_{i+0T} \Vert m_{i+1T} \Vert \ldots \Vert m_{i+(L-1)T}, K)$\;
\Return{$k$}
\caption{ciphart}
\label{alg_ciphart}
\end{algorithm}

\section{parallelism}
since iterations of the loop in \cref{ciphart_lanes} in \cref{alg_ciphart}
are fully independent of one other, they can quite happily utilise $L$ cpu
cores, specially when segment sizes, $T$, are larger.

\section{memory-hardness}
\begin{proof}
    \cref{alg_ciphart} is just a variation of \emph{argon2d}, except that
    it uses an encryption function, $\enc$, instead of a hashing functionn.
    so if \emph{argon2d} is memory-hard, then so is \emph{ciphart}.
\end{proof}

\section{security interpretation}
\subsection{without \emph{ciphart}}
let's say that we used block encryption function $\enc$ and a key $v \gets
\hash(p \Vert s, V)$ to encrypt some clear-text into a sequence of
$C$-byte cipher-text blocks $m_0, m_1, \ldots$.  let's say that the
adversary got those $m_0, m_1, \ldots$.

adversary's goal is to decrypt those cipher-text blocks back into the
original clear-text.  so what options does he have?
\begin{itemize}
    \item \emph{option 1:} brute-force the $V$-bytes key space.  in order
    to get a probability of $1$ of finding the key $v$, the adversary would
    need to evaluate $2^{8V}$ many keys\footnote{assuming that each
    byte is $8$ bits.}.

    this works by having the adversary repeatedly decrypting $m_0$ with
    $\enc$, each time using a new key among
    \begin{itemize}
        \item $\hat v_0 \gets \texttt{0x00\ldots 0}$,
        \item $\hat v_1 \gets \texttt{0x00\ldots 1}$,
        \item $\vdots$
        \item $\hat v_{2^{H(p)}-1} \gets \texttt{0xff\ldots f}$,
    \end{itemize}
    until the adversary finds a key that manages to decrypt $m_0$.

    the adversary could be extremely lucky and have $v_0$ manage to decrypt
    $m_0$, hence needing to call $\enc$ only once.  

    or he might be extremely unlucky and need to keep trying until
    $v_{2^{8V}-1}$ manages to do it, hence needing to call $\enc$ for
    $2^{8V}$ many times.

    usually it's sometime in between.  asymptotically on on average, the
    adversary would need to call $\enc$ for $2^{8V}/2$ many times.

    but in order to guarantee finding $v$, the brute-forcing process would
    need to run $2^{8V}$ many evaluations, hence calling $\enc$ for
    $2^{8V}$ many times.

    \item \emph{option 2:} brute-force the $H(p)$ bits password space.
    where $H(p)$ is the amount of entropy bits in $p$.  in order to get a
    probability of $1$ of finding the password $p$, the adversary would
    need to evaluate $2^{H(p)}$ many keys\footnote{the adversary does not
    know $p$, obviously, but he knows the process that the user used to
    generate $p$, henceforth he knows $H(p)$.}.

    this works by having the adversary repeatedly decrypting $m_0$ with
    $\enc$, each time using a new key among:
    \begin{itemize}
        \item $\hat v_0 \gets \hash(\hat p_0 \Vert s, V)$,
        \item $\hat v_1 \gets \hash(\hat p_1 \Vert s, V)$,
        \item $\vdots$
        \item $\hat v_{2^{H(p)}-1} \gets \hash(\hat p_{2^{H(p)}-1} \Vert s,
        V)$,
    \end{itemize}
    until the adversary finds a key that manages to decrypt $m_0$.

    in order to guarantee finding $v$, the brute-forcing process would need
    to call $\enc$ for $2^{H(p)}$ many times.
\end{itemize}

unless the adversary is an idiot, he will try to attack the weakest element
in the chain: \emph{option 2}, since $H(p) < 8V$ is almost always true for
any $p$ that is memorable by humans.

knowing the strategy above, we'd be very dumb to choose a password $p$ with
more entropy than $8V$ bits.  because we would end up needlessly memorising
a password that is too long.  why?  because if $H(p) > 8V$, the weakest
element in the chain becomes \emph{option 1} instead, and the attacker
wouldn't bother with passwords, hence any extra password memorisation
effort was pointless.

\textbf{security interpretation:}  your protection against password
brute-forcing attacks is $\min(H(p), 8V)$ entropy bits.

\subsection{with \emph{ciphart}}
adversary's options are:
\begin{itemize}
    \item \emph{option 1:} identical to the case without \emph{ciphart}.
    \item \emph{option 3:} this is similar to \emph{option 2} except for
    evaluating keys from:
    \begin{itemize}
        \item $\hat v_0 \gets \kdf(\enc, \hat p_0, s, M, L, T, B, K)$,
        \item $\hat v_1 \gets \kdf(\enc, \hat p_1, s, M, L, T, B, K)$,
        \item $\vdots$
        \item $\hat v_{2^{H(p)}-1} \gets \kdf(\enc, \hat p_{2^{H(p)}-1}, s, M,
        L, T, B, K)$,
    \end{itemize}
    where $\enc$ is the same function that's used to encrypt cipher-texts $m_0,
    m_1, \ldots$ and $K = V$.
\end{itemize}

why should it be the same encryption function and $K=V$?  because it's the
case where \emph{ciphart} has a guaranteed interpretation as i show later
on.  \emph{ciphart} may also have a guaranteed interpretation with
different encryption functions and with $K \ne V$, but i don't know it yet.
so let's stick with identical encryption functions and $K=V$ for now.

each time the function $\kdf$ is called, the encryption function $\enc$ is
called $N$ many times, where $N\ge2^B$.  as per \cref{alg_ciphart}, there
is no way for the adversary to cheat by reducing $N$ for as long as $\enc$
is not broken.  the guarantee that the adversary cannot reduce $N$ is
cryptographic, and is totally independent of the implementation of his
brute-forcing apparatus.

so, when $\kdf$ is called for $2^{H(p)}$ many times, it \emph{necessarily}
has to result in calling $\enc$ for $N2^{H(p)} = 2^{H(p) + \log_2N}$ many
times.

meaning, using $\kdf$ with $p$ would have the \emph{same} computational
effect to the case of using just $\hash$ but with a more complex password
$\hat p$, such that:
\begin{equation}
    H(\hat p) = H(p) + \log_2 N
\end{equation}

also, since the encryption algorithm that's used by $\kdf$ is the same as
the one that's used to encrypt cipher-text blocks $m_0, m_1, \ldots$, we
know that if it costs the adversary $c$-many units of money for a single
call to $\enc$ with strategy \emph{option 1}, it will necessarily have to
cost him $cN$ units of money with strategy \emph{option 3}, because $\kdf$
in \emph{option 3} is using the same $\enc$ that's used in \emph{option 1}.

this way, it doesn't matter to us what kind of alien technology that
adversary has:  if one call to $\enc$ costs him $c$ units of money, then
using $\kdf$ will make his calls to $\enc$ increase $N$ fold.

\textbf{security interpretation:}  your protection against password
brute-forcing attacks is $\ge \min(H(p) + \log_2 N, 8V)$ \emph{relative
entropy bits}.

\section{comparison}
\section{summary}

\end{document}
