\documentclass[twocolumn]{article}
\usepackage[margin=.7in]{geometry}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{cleveref} % must be loaded last
\DeclareMathOperator{\enc}{enc}
\DeclareMathOperator{\maxf}{max}
\DeclareMathOperator{\len}{len}
\renewcommand{\contentsname}{content}
\makeatletter
\def\myrulefill{\leavevmode\leaders\hrule height .6ex width 1ex depth -0.4ex\hfill\kern\z@}
\makeatother
\begin{document}
\SetAlgorithmName{algorithm}{}{list of algorithms}

\begin{center}
\Huge
\myrulefill\ ciphart \myrulefill\\
\LARGE
key derivation with easier measurable security\\
\normalsize
caveman\\
\today\\
\rule{1\columnwidth}{2pt}
\end{center}

\emph{argon2}\footnote{\url{https://github.com/P-H-C/phc-winner-argon2}}
is mostly nice, but trying to interpret its contribution to enhancing the
protection against password brute-forcing attacks remains more difficult
than it should be.  this is a problem that is also shared with every other
key derivation function that i've known so far.

when one uses \emph{argon2}, his derived key will surely have superior
protection against password brute-forcing attacks, but by how much?  to
answer this, one would need to survey the industry that manufactures
application-specific integrated circuits to obtain a map between
\emph{time} and \emph{money}.  the centre of my thesis is that this part is
not nice, because i found that life can be easier.

henceforth, i propose \emph{ciphart} --- a memory-hard key derivation
function with a security contribution that is measured in a unit that i
propose: \emph{relative entropy bits}.  this unit is measured objectively
and is guaranteed to be true irrespective of whatever alien technology the
adversary might have.

\texttt{libciphart}\footnote{\url{https://github.com/Al-Caveman/libciphart}}
--- a library that implements \emph{ciphart} very closely to this paper,
without much fluff.  this should make integrating \emph{ciphart} into other
systems more convenient.
\texttt{ciphart}\footnote{\url{https://github.com/Al-Caveman/ciphart}} ---
a tool for encrypting and decrypting files that makes use of
\texttt{libciphart}.  this tool is meant to be used by humans or scripts.

\section{ciphart}
\subsection{parameters}
\begin{tabular}{lp{7.5cm}}
    $\enc$ & encryption function.  this also defines $C$.  e.g. if $\enc$
    is \emph{xchacha20}, then $C=64$ bytes to reflect its block size.\\
    $p$ & password.\\
    $s$ & salt.\\
    $L$ & number of memory lanes for concurrency.\\
    $M$ & total memory in bytes, increased to nearest multiple of $2CL$.\\
    $T$ & number of $C$-byte tasks per lane segment.\\
    $R$ & number of rounds per task.\\
    $B$ & added security in \emph{relative entropy bits}.\\
    $K$ & output key size in bytes.\\
\end{tabular}

\subsection{internal variables}
\begin{tabular}{lp{7.5cm}}
    $\hat M$   & $\gets M - (M \bmod 2CL) + 2CL$.  this is to ensure that
    it is in multiples of $2CL$.\\
    $G$   & $\gets \hat M/C/T/L$; total number of segments per lane.\\
    $\hat B$& $\gets \begin{cases}
                    B & \text{if } B \ge \log_2(GLTR)\\
                    \log_2(GLTR) & \text{otherwise}\\
                 \end{cases}$\\
            & this is to ensure that $\hat B$ is large enough to have at
            least one pass over the $\hat M$ bytes memory.\\
    $m_i$ & $C$ bytes memory for $i^{th}$ task in $\hat M$-bytes pad.\\
    $n_l$ & $\gets lG$; nonce variable for $l^{th}$ lane with
    at least $64$ bits.\\
    $f$   & $\gets \text{false}$; a flag indicating whether the $\hat
    M$-byte pad is filled.\\
\end{tabular}

\subsection{output}
\begin{tabular}{ll}
$k$ & $K$-bytes key with $\ge B$ \emph{relative entropy bits}.\\
\end{tabular}

\begin{algorithm}[tbh]
\While{true}{
    \For{$g=0, 1, \ldots, G-1$}{
        \For{$l=0, 1, \ldots, L-1$}{
            \For{$t=0, 1, \ldots, T-1$}{
                \For{$r=0, 1, \ldots, R-1$}{
                    $i \gets gT + t$\;
                    \uIf{$t = 0$}{
                        $j \gets i + T - 1$\;
                    }\uElseIf{$t = T - 1$}{
                        $j \gets i + 1 - T$\;
                    }\Else{
                        $j \gets i + 1$\;
                    }
                    $m_j \gets \enc(m_i, n_l, k)$\;
                    $n_l \gets n_l + 1$\;
                    $k \gets f(m_j, p, l, s, t)$\;
                }
            }
        }
        \If{$f = \text{true}$ {\bf and} $\log_2(n_1L) \ge B$}{
            \textbf{go to} \cref{ciphart_out}\;
        }
    }
    $f \gets \text{true}$\;
}
\While{true}{\label{ciphart_out}
    \For{$l=1, 2, \ldots, L$}{
        \lIf{$\len(k) \ge K$}{\Return $k[0:K]$}
        $n \gets n + 1$\;
        $k \gets k \mathbin\Vert \enc(m_{l,S,T}[1], n, k)$\;
    }
}
\caption{ciphart version 6}
\label{alg_ciphart}
\end{algorithm}

\section{parallelism}
\section{memory-hardness}
\section{security interpretation}
\section{comparison}
\section{summary}

\end{document}
