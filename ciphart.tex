\documentclass[twocolumn]{article}
\usepackage[margin=.7in]{geometry}
\usepackage{xhfill}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{cleveref} % must be loaded last
\DeclareMathOperator{\enc}{enc}
\DeclareMathOperator{\maxf}{max}
\DeclareMathOperator{\len}{len}
\renewcommand{\contentsname}{content}
\begin{document}
\SetAlgorithmName{algorithm}{}{list of algorithms}

\begin{center}
\Huge
\noindent\xrfill[.5ex]{2pt}ciphart\xrfill[.5ex]{2pt}\\
\LARGE
key derivation with easier measurable security\\
\normalsize
caveman\\
\today\\
\rule{1\columnwidth}{2pt}
\end{center}

i propose \emph{ciphart} --- a memory-hard key derivation function with a
security gain that's measurable more objectively and more conveniently than
anything in class known to date, while maintaining a memory-hardness
identical to
argon2d\footnote{\url{https://github.com/P-H-C/phc-winner-argon2}}.

to nail this goal, \emph{ciphart}'s security gain is measured in the unit
of \emph{relative entropy bits}.  relative to what?  relative to the
encryption algorithm that's used later on.

therefore, this measure is guaranteed to hold irrespective of adversary's
hardware, for as long as the encryption algorithm that's used with
\emph{ciphart} is also the same one that's used to encrypt the data
afterwards.

my reference implementation is available
here\footnote{\url{https://github.com/Al-Caveman/ciphart}}.

\section{ciphart}
\subsection{users' parameters}
\begin{tabular}{ll}
    $M$ & total memory in multiples of $2 \times 64$ bytes.\\
    $T$ & maximum number of tasks per lane segment.\\
    $R$ & number of rounds per task.\\
    $B$ & added security in \emph{relative entropy bits}.\\
    $L$ & number of lanes for concurrency.\\
    $S$ & salt.\\
    $K$ & output key size in bytes.\\
    $\enc$ & encryption function.\\
    $p$ & passphrase.\\
\end{tabular}

\subsection{algorithm's parameters}
\begin{tabular}{ll}
    $m_i$ & $64$ bytes memory for $i^{th}$ task in $M$-bytes pad.\\
    $n$   & nonce variable with at least $64$ bits.\\
\end{tabular}

\subsection{algorithm's output}
\begin{tabular}{ll}
$k$ & $K$-bytes key with $\ge B$ \emph{relative entropy bits}.\\
\end{tabular}

\subsection{algorithm's steps}
shown in \cref{alg_ciphart}.

\begin{algorithm}[tbh]
\While{true}{
    \For{$s=1, 2, \ldots, S$}{
        \For{$l=1, 2, \ldots, L$}{
            \For{$t=1, 2, \ldots, T$}{
                \For{$r=1, 2, \ldots, R$}{
                    \eIf{$t = 1$}{
                        $m_{l,s,t} \gets \enc(m_{l,s,T}, n, k)$\;
                    }{
                        $m_{l,s,t} \gets \enc(m_{l,s,t-1}, n, k)$\;
                    }
                    $n \gets n + 1$\;
                    $k \gets f(m_{l,s,t}[-64:], p, l, s, t)$\;
                }
            }
        }
        \If{$\log_2 n \ge B$}{
            \textbf{go to} \cref{ciphart_out}\;
        }
    }
}
\While{true}{\label{ciphart_out}
    \For{$l=1, 2, \ldots, L$}{
        \If{$\len(k) \ge K$}{
            \Return $k[0:K]$
        }
        $n \gets n + 1$\;
        $k \gets k \mathbin\Vert \enc(m_{l,S,T}[1], n, k)$\;
    }
}
\caption{ciphart version 6}
\label{alg_ciphart}
\end{algorithm}

\section{parallelism}
\section{memory-hardness}
\section{security interpretation}
\section{comparison}
\section{summary}

\end{document}
