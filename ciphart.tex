\documentclass{article}
\usepackage[a4paper, total={7in, 8in}]{geometry}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{algorithmic}
\DeclareMathOperator{\enc}{enc}
\DeclareMathOperator{\maxf}{max}
\DeclareMathOperator{\nonce}{nonce}
\DeclareMathOperator{\hash}{hash}
\usepackage{url}
\renewcommand{\contentsname}{content}

\author{caveman}
\title{key derivation with easier measurable security}
\begin{document}
\begin{multicols}{2}
\maketitle

hi --- i propose \emph{ciphart}, a sequential memory-hard key derivation
function that has a security gain that's measurable more objectively and
more conveniently than anything in class known to date.

to nail this goal, \emph{ciphart}'s security gain is measured in the unit
of \emph{relative entropy bits}.  relative to what?  relative to the
encryption algorithm that's used later on.  therefore, this \emph{relative
entropy bits} measure is guaranteed to be true when the encryption
algorithm that's used with \emph{ciphart} is also the same one that's used
to encrypt the data afterwards.

my reference implementation is available
here\footnote{\url{https://github.com/Al-Caveman/ciphart}}.

\tableofcontents
\vfill\null
\columnbreak

\section{ciphart}
\noindent\textbf{parameters:}

\begin{tabular}{lp{18em}}
    $M$   & each task's size, at least $32$ bytes.\\
    $W$   & total memory in multiples of $2M$.\\
    $R$ & number of rounds per task.\\
    $B$ & added security in relative entropy bits.\\
    $\enc$ & encryption function.\\
    $k$ & initial key.\\
\end{tabular}

\noindent\textbf{input:}

\begin{tabular}{lp{18em}}
    $T$ & $\leftarrow W/M$\\
    $P$ & $\leftarrow \maxf(2, \lceil2^B / (TR)\rceil)$\\
    $x$ & $\leftarrow 0$, a $16$ bytes wide variable.\\
    $m_t$ & for any task $t \in \{1,2,\ldots,T\}$, $m_t$ is $M$-bytes memory
    for $t^{th}$ task to work on.  $m_t[0:16]$ means first $16$ bytes.
    $m_t[-16:]$ means last $16$ bytes.\\
    $\nonce$ & a variable with enough bytes to store nonces in.\\
    $\hash$ & a function to compress $W$ bytes into desired key length.\\
\end{tabular}

\noindent\textbf{output:}

\begin{tabular}{lp{18em}}
$\hat k$ & better key, with $B$, or more, \emph{relative entropy bits}.
specifically, with $\log_2(PTR) \ge B$ bits.\\
\end{tabular}

\noindent\textbf{steps:}

\begin{algorithmic}[1]
    \FOR{$p=1, 2, \ldots, P$}
        \FOR{$t=1,3, \ldots, T-1$, in steps of $2$}
            \STATE $i \leftarrow t$
            \STATE $j \leftarrow t+1$
            \FOR{$r=1, 2, \ldots, 2R$}
                \STATE $\nonce \leftarrow (p, t, r)$
                \STATE $m_i \leftarrow \enc(m_j, \nonce, k)$
                \STATE $\hat i \leftarrow i$
                \STATE $i \leftarrow j$
                \STATE $j \leftarrow \hat i$
            \ENDFOR
            \STATE $x \leftarrow x \oplus m_i[-16:]$
            \STATE $x \leftarrow x \oplus m_j[-16:]$
        \ENDFOR
        \FOR{$t=1, 2, \ldots, T$}
            \STATE $m_t[0:16] \leftarrow m_t[0:16] \oplus x$
        \ENDFOR
    \ENDFOR
    \RETURN $\hat k \leftarrow \hash(m_1, m_2, \ldots, m_T)$
\end{algorithmic}
\vfill\null
\columnbreak

\section{parallelism}
\section{sequential-memory hardness}
\section{security interpretation}
\section{comparison}
\section{summary}

\end{multicols}
\end{document}
