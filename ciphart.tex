\documentclass[twocolumn]{article}
\usepackage[margin=.7in]{geometry}
\usepackage{url}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{cleveref} % must be loaded last
\DeclareMathOperator{\enc}{enc}
\DeclareMathOperator{\maxf}{max}
\DeclareMathOperator{\len}{len}
\renewcommand{\contentsname}{content}
\makeatletter
\def\myrulefill{%
    \leavevmode\leaders\hrule%
    height .6ex width 1ex depth -0.4ex%
    \hfill\kern\z@%
}
\makeatother
\begin{document}
\SetAlgorithmName{algorithm}{}{list of algorithms}

\begin{center}
\Huge
\myrulefill\ ciphart \myrulefill\\
\LARGE
memory-hard key derivation \\
with easier measurable security\\
\normalsize
caveman\\
\today\\
\rule{1\columnwidth}{2pt}
\end{center}

\emph{argon2}\footnote{\url{https://github.com/P-H-C/phc-winner-argon2}}
is mostly nice, but trying to interpret its contribution to enhancing the
protection against password brute-forcing attacks remains more difficult
than it should be.  this is a problem that is also shared with every other
key derivation function that i've known so far.

when one uses \emph{argon2}, his derived key will surely have superior
protection against password brute-forcing attacks, but by how much?  to
answer this, one would need to survey the industry that manufactures
application-specific integrated circuits to obtain a map between
\emph{time} and \emph{money}.  the centre of my thesis is that this part is
not nice, because i found that life can be easier.

so i propose \emph{ciphart} --- a memory-hard key derivation function with
a security contribution that is measured in a unit that i call
\emph{relative entropy bits}.  this unit is measured objectively and is
guaranteed to be true irrespective of whatever alien technology the
adversary might have.

\texttt{libciphart}\footnote{\url{https://github.com/Al-Caveman/libciphart}}
is a library that implements \emph{ciphart} very closely to this paper,
without much fluff.  this should make integrating \emph{ciphart} into other
systems more convenient.
\texttt{ciphart}\footnote{\url{https://github.com/Al-Caveman/ciphart}} is a
tool for encrypting and decrypting files that makes use of
\texttt{libciphart}.  the latter is meant to be used by end-users or
scripts.

\tableofcontents
\vfill
\break

\section{ciphart}
\subsection{parameters}
\begin{tabularx}{\columnwidth}{lX}
    $\enc$ & encryption function.\\
    $p$ & password.\\
    $s$ & salt.\\
    $L$ & number of memory lanes for concurrency.\\
    $M$ & total memory in bytes.\\
    $T$ & number of tasks per lane segment.\\
    $R$ & number of rounds per task.\\
    $B$ & added security in \emph{relative entropy bits}.\\
    $K$ & output key size in bytes.\\
\end{tabularx}

\subsection{internal variables}
\begin{tabularx}{\columnwidth}{lX}
    $C$         & $\gets \begin{cases}
                        64 & \text{if $\enc$ is \emph{xchacha20}}\\
                        16 & \text{if $\enc$ is \emph{aes}}\\
                        \ldots & \\
                     \end{cases}$\\
                & this to reflect the block size of the encryption
                algorithm that's going to use \emph{ciphart}'s generated
                key to encrypt data.\\
    $\hat T$    & $\gets T - (T \bmod 2) + 2$.  this is to
                    ensure that it is in multiples of $2$.\\
    $\hat M$    & $\gets M - (M \bmod C\hat TL) + C\hat TL$.  this is to
                    ensure that it is in multiples of $C\hat TL$.\\
    $G$         & $\gets \hat M/C/T/L$; total number of segments per
                    lane.\\
    $\hat B$    & $\gets \begin{cases}
                        B & \text{if } B \ge \log_2(GLTR)\\
                        \log_2(GLTR) & \text{otherwise}\\
                     \end{cases}$\\
                & this is to ensure that $\hat B$ is large enough to have
                    at least one pass over the $\hat M$ bytes memory.\\
    $m_i$       & $C$ bytes memory for $i^{th}$ task in $\hat M$-bytes
                    pad.\\
    $n_l$       & $\gets lG$; nonce variable for $l^{th}$ lane with at
                    least $64$ bits.\\
    $f$         & $\gets {\bf false}$; a flag indicating whether the $\hat
                    M$-bytes pad is filled.\\
\end{tabularx}

\subsection{output}
\begin{tabular}{ll}
$k$ & $K$-bytes key with $\ge B$ \emph{relative entropy bits}.\\
\end{tabular}

\subsection{steps}
shown in \cref{alg_ciphart}.

\begin{algorithm}[tbh]
\While{true}{
    \For{$g=0, 1, \ldots, G-1$}{
        \For{$l=0, 1, \ldots, L-1$}{
            \For{$t=0, 1, \ldots, T-1$}{
                \For{$r=0, 1, \ldots, R-1$}{
                    $i \gets gT + t$\;
                    \uIf{$t = 0$}{
                        $j \gets i + T - 1$\;
                    }\uElseIf{$t = T - 1$}{
                        $j \gets i + 1 - T$\;
                    }\Else{
                        $j \gets i + 1$\;
                    }
                    $m_j \gets \enc(m_i, n_l, k)$\;
                    $n_l \gets n_l + 1$\;
                    $k \gets f(m_j, p, l, s, t)$\;
                }
            }
        }
        \If{$f = {\bf true}$ {\bf and} $\log_2(n_1L) \ge B$}{
            \textbf{go to} \cref{ciphart_out}\;
        }
    }
    $f \gets \text{true}$\;
}
\While{true}{\label{ciphart_out}
    \For{$l=1, 2, \ldots, L$}{
        \lIf{$\len(k) \ge K$}{\Return $k[0:K]$}
        $n \gets n + 1$\;
        $k \gets k \mathbin\Vert \enc(m_{l,S,T}[1], n, k)$\;
    }
}
\caption{ciphart version 6}
\label{alg_ciphart}
\end{algorithm}

\section{parallelism}
\section{memory-hardness}
\section{security interpretation}
\section{comparison}
\section{summary}

\end{document}
