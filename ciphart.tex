\documentclass[twocolumn]{article}
\usepackage[margin=.7in]{geometry}
\usepackage{xhfill}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{cleveref} % must be loaded last
\DeclareMathOperator{\enc}{enc}
\DeclareMathOperator{\maxf}{max}
\DeclareMathOperator{\len}{len}
\renewcommand{\contentsname}{content}
\begin{document}
\SetAlgorithmName{algorithm}{}{list of algorithms}

\begin{center}
\Huge
\noindent\xrfill[.5ex]{2pt}ciphart\xrfill[.5ex]{2pt}\\
\LARGE
key derivation with easier measurable security\\
\normalsize
caveman\\
\today\\
\rule{1\columnwidth}{2pt}
\end{center}

i propose \emph{ciphart} --- a memory-hard key derivation function with a
security gain that's measurable more objectively and more conveniently than
anything in class known to date, while maintaining a memory-hardness
identical to
argon2d\footnote{\url{https://github.com/P-H-C/phc-winner-argon2}}.

to nail this goal, \emph{ciphart}'s security gain is measured in the unit
of \emph{relative entropy bits}.  relative to what?  relative to the
encryption algorithm that's used later on.

therefore, this measure is guaranteed to hold irrespective of adversary's
hardware, for as long as the encryption algorithm that's used with
\emph{ciphart} is also the same one that's used to encrypt the data
afterwards.

my reference implementation is available
here\footnote{\url{https://github.com/Al-Caveman/ciphart}}.

\section{ciphart}
\subsection{parameters}
\begin{tabular}{ll}
    $M$ & total memory in multiples of $2 \times 64$ bytes.\\
    $T$ & number of $64$-byte tasks per lane segment.\\
    $R$ & number of rounds per task.\\
    $B$ & added security in \emph{relative entropy bits}.\\
    $L$ & number of lanes for concurrency.\\
    $S$ & salt.\\
    $K$ & output key size in bytes.\\
    $\enc$ & encryption function.\\
    $p$ & passphrase.\\
\end{tabular}

\subsection{internal variables}
\begin{tabular}{lp{7.5cm}}
    $G$   & $\gets M/64/T/L$; total number of segments.\\
    $m_i$ & $64$ bytes memory for $i^{th}$ task in $M$-bytes pad.\\
    $n_l$ & $\gets lG$; nonce variable for $l^{th}$ lane with
    at least $64$ bits.\\
    $f$   & $\gets \text{false}$; a flag indicating whether the $M$-byte
    pad is filled.\\
\end{tabular}

\subsection{output}
\begin{tabular}{ll}
$k$ & $K$-bytes key with $\ge B$ \emph{relative entropy bits}.\\
\end{tabular}

\subsection{steps}
shown in \cref{alg_ciphart}.

\begin{algorithm}[tbh]
\While{true}{
    \For{$g=0, 1, \ldots, G-1$}{
        \For{$l=0, 1, \ldots, L-1$}{
            \For{$t=0, 1, \ldots, T-1$}{
                \For{$r=0, 1, \ldots, R-1$}{
                    $i \gets gT + t$\;
                    \uIf{$t = 0$}{
                        $j \gets i + T - 1$\;
                    }\uElseIf{$t = T - 1$}{
                        $j \gets i + 1 - T$\;
                    }\Else{
                        $j \gets i + 1$\;
                    }
                    $m_j \gets \enc(m_i, n_l, k)$\;
                    $n_l \gets n_l + 1$\;
                    $k \gets f(m_j, p, l, s, t)$\;
                }
            }
        }
        \If{f = \text{true} \textbf{and} $\log_2(n_1L) \ge B$}{
            \textbf{go to} \cref{ciphart_out}\;
        }
    }
    $f \gets \text{true}$\;
}
\While{true}{\label{ciphart_out}
    \For{$l=1, 2, \ldots, L$}{
        \lIf{$\len(k) \ge K$}{\Return $k[0:K]$}
        $n \gets n + 1$\;
        $k \gets k \mathbin\Vert \enc(m_{l,S,T}[1], n, k)$\;
    }
}
\caption{ciphart version 6}
\label{alg_ciphart}
\end{algorithm}

\section{parallelism}
\section{memory-hardness}
\section{security interpretation}
\section{comparison}
\section{summary}

\end{document}
